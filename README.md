# Postgres

## Определение проблемы
 Всем измвестно, что EntityFramework создает таблицы и колонки в базе данных с сохранением регистра в названиях. 
И в общем-то ни чего полохого в этом нет, но при использовании базы данных PostgreSQL я столкнулся с очень неприятной проблемой. 
При обращении к таблицам и колонкам, через саму БД в утилите psql или pgAdmin4, когда в названиях присутствует верхний регистр, каждое наименование нужно заключать в двойные кавычки.  
Пример: 
```SQL
SELECT "Id", "Name","LastName", "Age"
FROM "Users";
```

## Проблема при решении проблемы
 Для того, чтобы решить вопрос с повсеместным использованием кавычек в запросе, нужно все наименования привести к нижнему регистру.  
Различают два пути: 
- Исползование атрибутов (Data Annotations)
```C#
[Table("users")] 
public class User
{
    [Column("id")]
    public int Id { get; set; }
    [Column("name")]
    public string Name { get; set; }
    [Column("last_name")]
    public string LastName { get; set; }
    [Column("age")]
    public int Age { get; set; }
}
```
- Использование FluentAPI
```C#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().ToTable("users");
    modelBuilder.Entity<User>().Property(u => u.Id).HasColumnName("id");
    modelBuilder.Entity<User>().Property(u => u.Name).HasColumnName("name");
    modelBuilder.Entity<User>().Property(u => u.LastName).HasColumnName("last_name");
    modelBuilder.Entity<User>().Property(u => u.Age).HasColumnName("age");
}
```

 Первый способ нагружает класс сущности. Второй нагружает класс контекста БД. 
Тем самым решая одну проблему сталкиваешься с другой, не менее важной. Которая ухудшает читаемость и понимание кода. 
И здесь в примере один небольшой класс User, и только с переименованием авто свойств. А что если сущность нужно изменить под БД куда сильнее: 
- изменить тип данных 
- наложить ограничения
- и многое другое...  

В таком случае проект сильно разрастается повторяющимися участками кода...


## Решение проблемы
 Для полного решения этой проблемы я использовал совокупность подходов, а именно: 
- FluentAPI с переносом в отдельный статический класс, разгрузив класс контекста БД. 
- Дженерики.
- Рефлексия/Отражение, что помогло использовать один и тот же код для разных сущностей БД. 
- Методы LINQ.  


## Описание
 Основная настройка сущностей производится через два словаря. Логика следующая: в один словарь перечисляются все таблицы для базы данных с указанием 
последующего названия, названия схемы, и списка ограничений; в другой словарь перечисляются все имеющиеся свойства сущностей с указанием названия, 
типа данных, дефолтного значения и будет ли изменена генерация значения для главного ключа таблицы у этого свойства. 
 Перечисление всех свойств в одном месте сделано в угоду отказа от повторения, так как у сущностей часто бывают одни и теже названия свойст с их характеристиками. 
При желании можно переделать на список свойств для каждой отдельной сущности. Здесь уже кому что больше нужно, более тонкая настройка 
либо меньше писанины. Между этим остаётся балансировать. Для меня достаточно реализации в данном виде.  
